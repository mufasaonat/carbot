<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Following Carbot</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container">
        <h1>CarBot: A Smart Line-Following Robot</h1>
        <h3>Overview</h3>
        <p>CarBot is an intelligent robot designed to follow a line or path autonomously using sensors and actuators.
            It’s an excellent project for students learning robotics, Arduino programming, and sensor integration. The
            CarBot introduces foundational concepts in robotics such as sensor input, decision-making, and motor control
        </p>
        <h3>How it works</h3>
        <p>CarBot primarily uses line-following sensors to detect a line on the surface, often marked in black on a
            white background or vice versa. By continuously reading the sensor data, CarBot adjusts its wheels' motion
            to stay on the line.</p>
        <h3>Key Components</h3>
        <ul class="key-components">
            <li>Arduino Microcontroller: Acts as the "brain" of the robot, processing data and sending commands.</li>
            <li>Line-Following Sensors: Detect the line and send signals to the Arduino.</li>
            <li>Motor Driver: Controls the speed and direction of the wheels.</li>
            <li>Wheels and Chassis: The physical components that move and carry the robot.</li>
            <li>Ultrasonic sensor: Detects the distance of an object</li>
            <li>Piezo Buzzer: Use as a sound signal.</li>
        </ul>
        <h3>Flowchart for CarBot Functionality</h3>
        <ul class="carbot-functionality">
            <li>Initialization: The Arduino initializes sensors and motor drivers.</li>
            <li>Sensor Reading: IR sensors detect whether they’re on the line or off.</li>
            <li>Decision-Making: Based on the sensor readings, the Arduino determines if the robot needs to turn left,
                right, or go straight.</li>
            <li>Motor Control: The Arduino sends commands to the motor driver to adjust wheel speed or direction.</li>
            <li>Repeat: The process loops continuously, allowing the CarBot to follow the line.</li>
        </ul>
        <div class="initial">
            <div class="motor">
                <h5>Motor Setup</h5>
                <pre>
                    int enablerA = 10; // speed control
                    int motorA = 12;
                    int enablerB = 11; // speed control
                    int motorB = 13;

                    void setup(){
                        pinMode(enablerA,OUTPUT);
                        pinMode(motorA,OUTPUT);
                        pinMode(enablerB,OUTPUT);
                        pinMode(motorB,OUTPUT);
                    }
                    
                    void loop() {
                        digitalWrite(motorA,HIGH);
                        analogWrite(enablerA,255);
                        digitalWrite(motorB,HIGH);
                        analogWrite(enablerB,255);
                    }
                    
                </pre>
                <p>
                    <img src="img/L298P-Motor-Driver-Shield-Back-150x150.jpg" alt="">
                </p>
                <div class="description">
                    <h2>Description</h2>
                    <p>
                        This Motor Driver Shield based on L298P motor driver IC is capable of driving two brushed motor,
                        with speed, direction, start and stop simultaneously. With two full H-bridge circuit, this motor
                        driver shield can also drive bipolar or unipolar stepper motor.</p>
                    <p>
                        Besides the L298P driver IC, it comes with tones of header pins and female header for GPIO of
                        Arduino. The ADC pins of Arduino main board are being extended to SVG (Signal Voltage Ground),
                        RC servo alike header pins. Making it simple for you to connect to sensor module with the extra
                        pin of GND and 5V.
                        Not to forget there are two types of Bluetooth module, mainly the HC05 or HC06. Another type
                        bluetooth connector is seldom being utilized.
                        This multi-featured motor shield based around the L298P driver chip fits onto Arduino Uno or
                        other Arduino UNO compatible boards.
                    </p>

                    <h4>Logic Power subsystem:</h4>
                    <p>
                        The Arduino's 5V is brought up to the shield and is available on:
                        <ul>
                            <li>6 sets of red sensor 5V pins(SVG) for Analog pin</li>
                            <li>Yellow Ping connector for Ultrasonic Rangefinders</li>
                            <li>Used to power the logic portion of the L298P chip.</li>
                        </ul>
                        This ensures that they have good clean 5V power independent of what the motors are doing.</p>
                    <p>
                        The Arduino's 3.3V is brought up to the shield and is available on the 2 Bluetooth connectors.
                        Arduino main board can be powered separately using the normal USB or DC power connector or
                        alternatively, it can also be powered from this Shield. To select this power path, there is a
                        jumper near the electrolytic cap labeled ‘OPT’. When this jumper is removed, the Arduino must be
                        powered separately. When the jumper is installed, the power from the motor VMS power connector
                        is connected to the Vin pin on the Arduino which feeds the Arduino on-board 5V regulator. To use
                        this option, the motor power input must be at least 6.5VDC and less than 12VDC to feed the
                        regulator. If powering the Arduino off the shield, the DC power jack on the Arduino should not
                        be used to avoid a power conflict, but the USB can be used.</p>

                    <h4>Motor Power Subsystem:</h4>
                    <p>The motor power comes in on the 2-pos screw terminal. The VMS is the positive motor voltage which
                        can range from 4.8 to 24VDC. If you are using this input to power the Arduino by installing the
                        ‘OPT’ jumper, the maximum input voltage on this terminal should be limited to 12V to avoid
                        overheating the Arduino regulator.</p>
                    <p>
                        VMS = Motor Vcc which must be between 4.8 and 24VDC GND = Motor Ground
                        This motor power is fed to a 5V regulator that is mounted to the bottom of the shield. This 5V
                        feeds the white servo connector(near to buzzer). This isolates any servo electrical noise from
                        getting back into the main 5V that powers the logic. For this 5V regulator to function, the VMS
                        voltage must be at least 6.3V and limited to 12VDC max to avoid heat to the 5V regulator.
                    </p>
                    <p>
                        Note: If you have the OPT jumper in place and USB connected, but there is no power on the VMS
                        motor connector, it will try to use the USB power to power the DC motors. This should be
                        avoided.
                    </p>
                    <p>
                        If you have the OPT jumper in place and power coming on the DC Jack on the Arduino, it will work
                        but the DC motor noise will be coupled into the 5V logic power supply and may cause eradicate
                        behavior and so it is not really recommended. In general, if you are using the motors, you
                        should plan to bring the motor power in on the VMS power connector for the most stable
                        operation.
                    </p>
                    <h4> Driving DC Motors:</h4>
                    <p>
                        The L298P contains two full H-Bridge drive channels that provide full speed and direction
                        control. The 2 DC motor drive channels can operate at voltages from 4.8 – 24V and at
                        currents of up to 2.0A (peak) and 1.0A continuous per channel.
                    </p>

                    <p>You can also have 2 motors share a motor drive channel as long as the combined current stays
                        within the 2A and you don’t mind the motors turning the same direction and speed. This is
                        typically the case when you have a 4 wheel drive robotic vehicle and the 2 wheels on each side
                        operate at the same speed and direction.
                    </p>
                    <p>The L298P motor driver uses Arduino pins D10, D11, D12 and D13 for motor control. Pins 10 & 11
                        are PWM pins and connect to the chip EN pins to provide speed control by modulating the enable
                        input. D10 controls speed of motor A and D11 controls speed of motor B. Pins 12 & 13 are
                        connected to the IN inputs to provide direction control. Pin 12 controls direction of motor A
                        and Pin 13 controls direction of motor B. Usually there are 2 pins used to determine the
                        direction of rotation for each motor, but this shield has an inverter that provides an inverted
                        version of the signal to the two pins. This reduces the number of pins used on the Arduino, but
                        it does remove the ability to do dynamic braking which usually isn’t an issue for most projects.
                        Reducing the speed control pins to a PWM value of zero will get things stopped.
                    </p>

                    <h4>DC Motor Connections:</h4>
                    <p>The motor connections are via a 4-way screw terminal block with 2 terminals for each motor that
                        are labeled MOTORA and MOTORB.</p>

                    <p>The +/- pins for each motor are not labeled, so it is somewhat arbitrary how your wire them and
                        relative to what you consider forward vs reverse motor operation. Basically if the motor goes in
                        the opposite direction than you expect, simply reverse the wiring for that motor.</p>

                    <p>
                        These motor connection points are also mirrored on a 4-pin female header for a little more
                        flexibility.
                    </p>

                    <p>
                        These motor drive leads also have yellow and green LEDs attached to them. Their brightness will
                        vary depending on the strength of the PWM signal.
                    </p>

                    <h4>Servo Motor Connections:</h4>
                    <p>
                        Servo motors are 3 wire devices. They require 5V, Ground and a PWM signal to set its position.
                        The shield uses D9 for the PWM signal. One nice feature of these modules is that it has a
                        dedicated 5V regulator to power the servo to prevent electrical noise from getting back into the
                        main 5V logic power.
                    </p>

                    <p>Servos are typically used to turn a small steering wheel or to rotate a sensor, such as an
                        ultrasonic rangefinder for obstacle avoidance.</p>

                    <p>To use the servo, you will need to have a minimum of 6.5VDC on the main motor power connector for
                        the regulator to operate.</p>
                    <p>If you are not using a servo, D9 as well as this dedicated 5V is available for other uses.
                    </p>

                    <h4>Arduino to Shield Pin Connections:</h4>
                    <p>
                        All of the I/O is brought up to stackable female headers on the shield except for the IOREF and
                        the two I2C pins hear the USB connector so it can support a daughter shield as long as it does
                        not conflict with the pins in use. In addition, many of these pins are broken out to other
                        headers for easy hookup.
                    </p>

                    <p>The shield uses the following pins which remain available if you are not using that function:</p>

                    <ul>
                        <li>Ultrasonic Sensor Ping Control = D7, D8</li>
                        <li>Servo motor control = D9</p>

                        <li> DC motor control = D10,D11, D12, D13</li>
                        <li> Buzzer = D4</li>
                        <li>Bluetooth</li>
                        <p>There are two Bluetooth connectors on the board. The first connector is a 4-pin header that brings out 3.3V power, ground, TX and RX. This type of connector is compatible with HC05 or HC06</p>
                        Bluetooth modules and perhaps some others. The Receive pin has a 1K/2K voltage divider to level shift the TX output of the Arduino to be 3.3V compatible which is a nice feature.
                        </li>
                    </ul <p>
                    </p>
                    1 x 4 Bluetooth ‘BT2’ Female Header (Black)

                    ‘+‘ = 3.3V
                    ‘–‘ = Ground
                    T = D0 (RX)
                    R = D1 (TX)
                    The other Bluetooth header is a 12-pin male header. The TX, RX 5V and ground are hooked up to
                    this header. The only 12-pin Bluetooth connectors are generally associated with automobiles, so
                    this connector does not seem to be of much use. The pin spacing is also 2mm rather than the
                    standard 2.54mm

                    Ultrasonic Rangefinder:
                    A common robotic interface is Ultrasonic Rangefinders such as the HC-SR04. These work by sending
                    out a ping of ultrasonic sound and timing how long it takes for the ping to come back. The board
                    has a dedicated 4-pin header to connect the sensor.

                    1 x 4 Ping Male Header (Yellow)

                    + = 5V
                    R = Return (D8)
                    T = Trigger (D7)
                    G = Ground
                    Analog / Digital Sensors:
                    A common issue when hooking sensors up to an Ardino is that many require Ground/VCC connections
                    as well as an analog input or digital I/O. This board brings out the A0-A5 pins to a row of
                    headers that also provide separate power and ground points for each A0-A5 pin, in SVG format.
                    The white headers are the signal lines, the red headers provide 5V and the black headers provide
                    ground.

                    The A0-A5 pins can be used either for analog inputs or as digital I/O, so both types of sensors
                    can be supported.

                    3 x 6 Header (White/Red/Black)

                    A0 / 5V / Ground
                    A1 / 5V / Ground
                    A2 / 5V / Ground
                    A3 / 5V / Ground
                    A4 / 5V / Ground
                    A5 / 5V / Ground
                    There is also a 3-pin blue header that that brings out 5V, ground and D2 that can be used for a
                    digital sensor or other remote connection

                    1 x 3 Header (Blue)

                    G = Ground
                    '+' = 5V
                    S = D2 – digital I/O
                    RGB LED:
                    And for good measure, there is a 5-pin header that brings out D3, D5, D6, 5V and Ground. This
                    puts 3 PWM outputs along with power and ground on a single connector which can be handy for a
                    number of things like driving an RGB LED, common cathode or anode type is supported

                    1 x 5 Header (Blue)

                    ‘ ‘ = 5V – This pin is unmarked but sits next to D7
                    B = D6 – B could be used for Blue on RGB LED
                    G = D5 – G could be used for Green on RGB LED
                    ‘-‘ = Ground
                    R = D3 – R could be used for Red on RGB LED
                    Buzzer:
                    The buzzer is wired to D4. It is active HIGH

                    Reset Switch:
                    The shield has a extra reset button located on it for easy access.
                    </p>
                </div>
                <div class="img">
                    <h5>Pin Configuration</h5>
                    <img src="img/L298P Motor Driver labelling.png" alt="pin-configuration">

                </div>
                <h3><a
                        href="https://th.cytron.io/p-shield-l298p-motor-driver-with-gpio?srsltid=AfmBOooVuzDyiaWOFurcM_bi8FZ9lWYx8U0pSl1k3RxaNPXs0jFqK49X">Cytron
                        Link</a>
                </h3>

            </div>
            <hr>
            <div class="ultrasonic">
                <h5>Ultrasonic Sensor Setup</h5>
                <a href="https://randomnerdtutorials.com/complete-guide-for-ultrasonic-sensor-hc-sr04/">Complete Guide
                    for Ultrasonic Sensor HC-SR04 with Arduino by Randomnerd</a>
                <pre>
                    /*
                    * created by Rui Santos, https://randomnerdtutorials.com
                    *
                    * Complete Guide for Ultrasonic Sensor HC-SR04
                    *
                    Ultrasonic sensor Pins:
                    VCC: +5VDC
                    Trig : Trigger (INPUT) - Pin11
                    Echo: Echo (OUTPUT) - Pin 12
                    GND: GND
                    */

                    int trigPin = 11; // Trigger
                    int echoPin = 12; // Echo
                    long duration, cm, inches;

                    void setup() {
                    //Serial Port begin
                    Serial.begin (9600);
                    //Define inputs and outputs
                    pinMode(trigPin, OUTPUT);
                    pinMode(echoPin, INPUT);
                    }

                    void loop() {
                    // The sensor is triggered by a HIGH pulse of 10 or more microseconds.
                    // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:
                    digitalWrite(trigPin, LOW);
                    delayMicroseconds(5);
                    digitalWrite(trigPin, HIGH);
                    delayMicroseconds(10);
                    digitalWrite(trigPin, LOW);

                    // Read the signal from the sensor: a HIGH pulse whose
                    // duration is the time (in microseconds) from the sending
                    // of the ping to the reception of its echo off of an object.
                    pinMode(echoPin, INPUT);
                    duration = pulseIn(echoPin, HIGH);

                    // Convert the time into a distance
                    cm = (duration/2) / 29.1; // Divide by 29.1 or multiply by 0.0343
                    inches = (duration/2) / 74; // Divide by 74 or multiply by 0.0135

                    Serial.print(inches);
                    Serial.print("in, ");
                    Serial.print(cm);
                    Serial.print("cm");
                    Serial.println();

                    delay(250);
                    }
                </pre>

            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous">
    </script>
</body>

</html>